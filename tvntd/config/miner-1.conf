peer.discovery = {

    # If peer discovery is on
    #   The discovery protocol will be used to find other nodes and connect them
    # If peer discovery is off
    #   This peer will only be connecting to the peers from [peer.active] list
    # inbound connections from other peers are accepted as well
    #
    enabled = false

    # List of the seed peers to start the search for online peers
    # values: [ip:port, enode://nodeid@ip:port, ip:port ...]
    #
    ip.list = [
        192.168.1.102:30305
        10.1.10.12:30305
    ]

    # External IP/hostname which is reported as our host during discovery
    # if not set, the service http://checkip.amazonaws.com is used
    # the last resort is to get the peer.bind.ip address
    #
    external.ip = null

    # Local network adapter IP to which the discovery UDP socket is bound
    # e.g: 192.168.1.104
    #
    # If the value is empty it will be retrieved
    # by punching to some known address e.g: www.google.com
    #
    bind.ip = ""

    # Indicates whether the discovery will include own home node
    # within the list of neighbor nodes
    #
    public.home.node = true

    # Indicates if the discovered nodes and their reputations
    # are stored in DB and persisted between VM restarts
    #
    persist = true

    # The period in seconds with which the discovery
    # tries to reconnect to successful nodes
    # 0 means the nodes are not reconnected
    #
    touchPeriod = 600

    # The maximum nuber of nodes to reconnect to
    # -1 for unlimited
    #
    touchMaxNodes = 100

    # Number of workers that test the peers for being online [1..10]
    #
    workers = 8
}

peer {
    # Port on which ethereumj will listen
    # for incoming connections
    #
    listen.port = 30305

    # Network id
    #
    networkId = 1973

    # Private key of the peer
    # The key is generated by default on the first run and stored in the database folder
    #
    privateKey = 2ce7296200d6764fb03df34c2db83fb5ad9256c1eaa2e38f59e40918c59d6925

    # Boot node list
    #
    active = [ {
        ip     = 192.168.1.102
        port   = 30305
        nodeId = 254a002050deb105db55e6465de0bf71263022261e8b879bb015913cf2ae838198c272fd5994d69ae2c5fef705222c1ea3aa0d508bdc20309cf69ca467c691eb
    }, {
        ip     = 10.1.10.12
        port   = 30305
        nodeId = e814e75b391641b33c4ed11f708f0531f66ebf41b7be5d6d8b05e3905235fa5aefa0a06ac722b3551db847d8ba36e409eef2ab24328449db4d0c2dffdd05f03e
    }, {
        ip     = 192.168.1.102
        port   = 30300
        nodeId = 46168d7373e3adc1b04fce6c3f7cc36f4f0ad9e6432bc19d5f7eb5926150457a8f2fd913d1613aadcfc927d2d546d0ababc2ce560b952bb85205dd4ed624de60
    } ]

    # List of trusted peers from which incoming connections are always accepted
    #
    trusted = [ {
        nodeId = 254a002050deb105db55e6465de0bf71263022261e8b879bb015913cf2ae838198c272fd5994d69ae2c5fef705222c1ea3aa0d508bdc20309cf69ca467c691eb
    }, {
        nodeId = e814e75b391641b33c4ed11f708f0531f66ebf41b7be5d6d8b05e3905235fa5aefa0a06ac722b3551db847d8ba36e409eef2ab24328449db4d0c2dffdd05f03e
    }, {
        nodeId = 46168d7373e3adc1b04fce6c3f7cc36f4f0ad9e6432bc19d5f7eb5926150457a8f2fd913d1613aadcfc927d2d546d0ababc2ce560b952bb85205dd4ed624de60
    } ]

    # Max number of active peers our node will maintain extra peers trying
    # to connect us will be dropped with TOO_MANY_PEERS message the incoming
    # connection from the peer matching 'peer.trusted' entry is always accepted
    #
    maxActivePeers = 30

    # The protocols supported by peer can be: [eth, shh, bzz]
    #
    capabilities = [eth]

    # Connection timeout for trying to connect to a peer [seconds]
    #
    connection.timeout = 2

    # How much time [seconds] we will wait for a message to arrive
    # before closing the channel
    #
    channel.read.timeout = 90

    p2p {
        # The default version outbound connections are made with
        # inbound connections are made with the version declared by the
        # remote peer (if supported)
        #
        # version = 4

        # Max frame size in bytes when framing is enabled
        #
        framing.maxSize = 32768

        # Forces peer to send Handshake message in format defined by EIP-8,
        # see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-8.md
        #
        eip8 = true
    }
}

# The folder resources/genesis contains several versions of genesis configuration
# according to the network the peer will run on
#
genesis = private-genesis.json
# genesis = frontier.json

# Path to genesis file has priority over `genesis` option
#
# genesisFile = /some/path/to/frontier.json

# This is a more advanced replacement for 'blockchain.config.name'
# Here the exact org.ethereum.config.BlockchainForkConfig implementation
# class name can be specified.
# Only one of two options (this and above) can be defined.
#
blockchain.config.class = "org.ethereum.config.blockchain.HomesteadConfig"

database {
    # Place to save physical storage files can be either absolute or relative path
    #
    dir = /Users/work/ws/data

    # every time the application starts the existing database will be destroyed and
    # all the data will be downloaded from peers again [true/false]
    #
    reset = false

    # If reset=true, every time the application starts the database will reset itself
    # to this block number and sync again from there.
    # Set to 0 for a 'full' reset.
    resetBlock = 0

    # Handling incompatible database version:
    #  * EXIT   - (default) show error in std out and exit by throwing Error
    #  * RESET  - clear database directory and continue working
    #  * IGNORE - continue working regardless possible issues
    # @since 1.4.0
    #
    incompatibleDatabaseBehavior = EXIT

    # Controls state database pruning
    # pruned state consumes much less disk space (e.g. 50G full and 1G pruned)
    # but the state can be restored only within last [maxDepth] blocks, all older
    # states are lost
    #
    prune {
        enabled = true

        # Controls how much last block states are not pruned
        # it is not recommneded to set this value below 192
        # as it can prevent rebranching from long fork chains
        #
        maxDepth = 192
    }
}

# Cache settings
#
cache {
    flush {
        # Size in Mbytes of the write buffer for all datasources
        # (state, blocks, transactions) data is flushed to DB when write caches
        # size exceeds this limit value < 0 disables this option
        #
        writeCacheSize = 64

        # Force data flush each N blocks [10000 flush each 10000 blocks]
        # value 0 disables this option
        #
        blocks = 0

        # Flush each block after full (long) sync complete
        #
        shortSyncFlush = true
    }

    # Total size in Mbytes of the state DB read cache
    #
    stateCacheSize = 256

    # The size of block queue cache to be imported in MBytes
    #
    blockQueueSize = 32

    # The size of header queue cache during import in MBytes
    #
    headerQueueSize = 8

    # Maximum size (in Mb) the state bloom fiter can grow up to when reaching this
    # threshold the bloom filter is turned off forever 128M can manage approx up to
    # 50M of db entries
    #
    maxStateBloomSize = 128
}

# eth sync process
sync {
    # Block chain synchronization can be: [true/false]
    #
    enabled = true

    # Fast sync options
    #
    fast {
        # Enables/disables fastsync when enabling make sure the global sync option
        # is enabled ('sync.enabled')
        #
        enabled = false

        # When specified the fastsync retrieves the state for this block
        # This is the fast and secure option to do fastsync
        # If not specified the block is selected like [peerBestBlockNumber - 1000]
        #
        # pivotBlockHash = 
    }

    # Minimal peers count used in sync process sync may use more peers
    # than this value but will try to get at least this many from discovery
    #
    peer.count = 1

    # Uncomment this param to use a strict Eth version.  Useful for testing
    #
    # version = 62

    # Exit if we receive a block that causes state conflict this option is
    # mainly for debugging purposes
    #
    exitOnBlockConflict = false
}

# Miner options
mine {
    # Start mining blocks when 'sync.enabled' is true the mining starts
    # when the sync is complete else the mining will start immediately,
    # taking the best block from database (or genesis if no blocks exist yet)
    #
    start = false

    # Number of CPU threads the miner will mine on 0 disables CPU mining
    #
    cpuMineThreads = 4

    # There two options for CPU mining 'light' and 'full' 'light' requires
    # only 16M of RAM but is much slower 'full' requires 1G of RAM and
    # possibly ~7min for the DataSet generation but is much faster during mining
    #
    fullDataSet = true

    # Mining beneficiary
    #
    coinbase = "4702058fe8468ab5a6985ff366a6bd64d165566b"

    # Extra data included in the mined block one of two properties should
    # be specified
    #
    extraData = "EthereumJ powered"
    #extraDataHex = "0102abcd"

    # Transactions with the gas price lower than this will not be included
    # in mined blocks decimal number in weis
    #
    minGasPrice = 15000000000  # 15 Gwei

    # Minimal timeout between mined blocks
    #
    minBlockTimeoutMsec = 0

    # Start mining with specific nonce (might be usefult for testing)
    # null for random start nonce
    #
    startNonce = null
}

# Solidity options
#
solc {
    # Full path to solc executable
    # If path is not provided, bundled Solidity Compiler is used
    #
    path = null
}

# ========================================================
#    Debug and advanced options
# ========================================================

# The time we wait to the network to approve the transaction, the
# transaction got approved when include into a transactions msg
# retrieved from the peer [seconds] transaction.approve.timeout = 15

# The number of blocks that should pass before a pending transaction is removed
#
transaction.outdated.threshold = 10

dump {
    # For testing purposes all the state will be dumped in JSON form to [dump.dir]
    # if [dump.full] = true possible values [true/false]
    #
    full = false
    dir = dump

    # This defines the vmtrace dump to the console and the style
    # -1 for no block trace styles: [pretty/standard+] (default: standard+)
    #
    block = -1
    style = pretty

    # Clean the dump dir each start
    #
    clean.on.restart = true
}

# Structured trace is the trace being collected in the form of objects and
# exposed to the user in json or any other convenient form.
#
vm.structured {
    trace = false
    dir = vmtrace
    compressed = true
    initStorageLimit = 10000
}

# Make changes to tracing options starting from certain block
# -1 don't make any tracing changes
#
trace.startblock = -1

# Enables/disables internal transactions data record a single
# transaction can potentially collect large amount of call data
# (especially in tests) so there is an option to disable it
#
record.internal.transactions.data = true

# Invoke vm program on message received, if the vm is not invoked
# the balance transfer occurs anyway  [true/false]
#
play.vm = true

# Hello phrase will be included in the hello message of the peer
#
hello.phrase = Dev

# This property used mostly for debug purposes so if you don't know
# exactly how to apply it, leave it as [-1]
#
# ADVANCED: if we want to load a root hash
# for db not from the saved block chain (last block)
# but any manual hash this property will help.
# values [-1] - load from db
#        [hex hash 32 bytes] root hash
#
root.hash.start = null

# Key value data source values: [leveldb/inmem]
#
keyvalue.datasource = leveldb

record.blocks=false
blockchain.only=false

# Load the blocks from a rlp lines file and not for the net
#
blocks.loader=""

# Crypto settings, such as sign, hash, etc
#
crypto {
	# JCA cryptoprovider name. 
    #
	providerName="SC"

	# Used for create JCA MessageDigest
    #
	hash.alg256="ETH-KECCAK-256"
	hash.alg512="ETH-KECCAK-512"
}
